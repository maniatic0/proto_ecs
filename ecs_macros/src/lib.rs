use proc_macro;
use quote::quote;
use std::sync::atomic::{AtomicU32, Ordering};
use syn::DeriveInput;

static COMPONENT_COUNT : AtomicU32 = AtomicU32::new(0);

/// Declare a struct as a datagroup. 
/// 
/// Intended usage: 
/// 
/// #\[datagroup]
/// 
/// struct MyDataGroup
/// { ... }
#[proc_macro_attribute]
pub fn datagroup(attr : proc_macro::TokenStream, item : proc_macro::TokenStream) -> proc_macro::TokenStream
{
    assert!(attr.is_empty());
    
    // We still need the factory fn and init params
    // Parsing name and creating crc
    let item_copy = item.clone();
    let DeriveInput{ident, ..} = syn::parse_macro_input!(item_copy);
    let component_id = COMPONENT_COUNT.fetch_add(1, Ordering::Relaxed);

    // Extend item with the required trait implementations
    let trait_impls = quote!{

        impl crate::data_group::DataGroupDesc for #ident
        {
            fn get_name() -> &'static str
            {
                std::any::type_name::<#ident>()
            }

            fn get_data_group_id() -> u32
            {
                return #component_id;
            }
        }

        impl crate::data_group::DataGroupDyn for #ident 
        {
            fn get_name(&self) -> &'static str
            {
                std::any::type_name::<#ident>()
            }
            
            fn dyn_init(&mut self, params: Box<dyn crate::data_group::DataGroupInitParamsDyn>) {
                let params = params.as_any();
                // let params = params.downcast_ref::<ExampleHealthDataGroupInitParams>();
                // let init_params = params.expect("Invalid type of parameter");
                // TODO What to do with this function...
                // ? How do we init the component here? The init function should be implemented automatically 
                // ? but it's not possible here since all this code should be auto generated by macros
            }

            fn as_any(&self) -> &dyn std::any::Any {
                self as &dyn std::any::Any
            }

            fn get_data_group_id(&self) -> u32
            {
                <#ident as crate::data_group::DataGroupDesc>::get_data_group_id()  
            }
        }
    };

    let mut item_copy = item.clone();
    item_copy.extend::<proc_macro::TokenStream>(trait_impls.into());

    return item_copy;
}

/// Make this struct usable as InitParams for a datagroup.
/// 
/// #\[derive(InitParams)]
/// 
/// struct MyInitParams
/// { ... }
#[proc_macro_derive(DataGroupInitParamsDyn)]
pub fn derive_datagroup_params(item : proc_macro::TokenStream) -> proc_macro::TokenStream
{
    let DeriveInput { ident, ..} = syn::parse_macro_input!(item);

    return quote!{
        impl crate::data_group::DataGroupInitParamsDyn for #ident
        {
            fn as_any(&self) -> &dyn std::any::Any {
                self as &dyn std::any::Any
            }
        }
    }.into();
}