use std::any::Any;

use crate::data_group::{DataGroupDesc, DataGroupDyn, DataGroupInitParamsDyn, DataGroupRegistry};
use super::*;

// The following code represents the code that should be generated by our macros 
// To actually implement the datagroup, use this as a guidance.
#[derive(Default)]
struct ExampleHealthDataGroup 
{
    health : u32,
    using_shield : bool
}

struct ExampleHealthDataGroupInitParams
{
    health : u32, 
    using_shield : bool
}

impl DataGroupInitParamsDyn for ExampleHealthDataGroupInitParams
{
    fn as_any(&self) -> &dyn std::any::Any {
        self as &dyn Any
    }
}

impl DataGroupDesc for ExampleHealthDataGroup
{
    fn get_name() -> &'static str
    {
        "ExampleHealthDataGroup"
    }

    fn get_data_group_id() -> u32 {
        42
    }
}

impl DataGroupDyn for ExampleHealthDataGroup 
{
    fn get_name(&self) -> &'static str
    {
        "ExampleHealthDataGroup"
    }

    // TODO Problematic function
    fn dyn_init(&mut self, params: Box<dyn DataGroupInitParamsDyn>) {
        let params = params.as_any();
        let params = params.downcast_ref::<ExampleHealthDataGroupInitParams>();
        let init_params = params.expect("Invalid type of parameter");
        
        // ? How do we init the component here? The init function should be implemented automatically 
        // ? but it's not possible here since all this code should be auto generated by macros
        self.health = init_params.health;
        self.using_shield = init_params.using_shield;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self as &dyn Any
    }

    fn get_data_group_id(&self) -> u32 {
        42
    }
}

impl proto_ecs::data_group::DataGroup for ExampleHealthDataGroup
{
    type InitParams = ExampleHealthDataGroupInitParams;

    fn init(&mut self, params: Self::InitParams) {
        self.health = params.health;
        self.using_shield = params.using_shield;
    }

    fn factory() -> Box<dyn DataGroupDyn> {
        Box::from(Self::default())
    }
}

// Intended api usage should be something like
/*

#[component]
struct MyComponent
{
    ...
}

#[derive(DatagroupInitParamsDyn)]
struct MyInitParams 
{
    ...
}

impl Component for MyComponent
{
    fn init(...)
    {
        ...
    }

    fn factory() -> Box<Dyn DataGroupDyn>
    {
        ...
    }
}

The #[component]  macro invocation should implement datagroup dyn and datagroup desc.
Also register the component in the global component registration system.
*/

// Example macro usage:
mod animation
{
    use crate::data_group;

    #[derive(Default)]
    #[data_group::datagroup]
    pub struct AnimationDataGroup
    { }

    crate::register_datagroup!(AnimationDataGroup);

    impl data_group::DataGroup for AnimationDataGroup
    {
        type InitParams = AnimationInitParams;

        fn init(&mut self, _params: Self::InitParams) {
            // Do something with params
        }

        // TODO It would be cool to have a macro or something to provide an optional default implementation 
        fn factory() -> Box<dyn data_group::DataGroupDyn> {
            Box::from(Self::default())
        }

    }

    #[derive(data_group::DataGroupInitParamsDyn)]
    pub struct AnimationInitParams 
    { }
}
mod mesh
{
    use crate::{data_group, register_datagroup};

    #[derive(Default)]
    #[data_group::datagroup]
    pub struct MeshDataGroup
    { }

    register_datagroup!(MeshDataGroup);

    #[derive(data_group::DataGroupInitParamsDyn)]
    pub struct MeshInitParams
    { }

    impl data_group::DataGroup for MeshDataGroup
    {
        type InitParams = MeshInitParams;
        fn factory() -> Box<dyn data_group::DataGroupDyn> {
            return Box::new(MeshDataGroup::default());
        }

        fn init(&mut self, _params: Self::InitParams) {
            // Do something
        }
    }
}

#[test]
pub fn test_data_group_api()
{
    let anim = animation::AnimationDataGroup{};
    let mesh = mesh::MeshDataGroup{};

    assert_ne!(anim.get_data_group_id(), mesh.get_data_group_id());
    assert_ne!(anim.get_name(), mesh.get_name());
}

#[test]
pub fn test_datagroup_loading()
{   
    // Run with cargo test -- --nocapture to see this output
    let global_registry = DataGroupRegistry::get_global_registry();
    global_registry.lock().and_then(|registry|{

        for item in registry.into_iter()
        {
            println!("My component is: {}", item.name);
        }
        return Ok(());
    }).expect("Should not fail");
}


// -- < Testing version 2 of the datagroups API > ---------------------------

#[cfg(test)]
mod animation_data_group2
{
    use proto_ecs::data_group2::*;

    use crate::get_id;

    // -- first example datagroup
    #[derive(DataGroupInitParams)]
    pub struct AnimationDataGroup
    {
        clip_name : String,
        duration : f64
    }

    impl DataGroup for AnimationDataGroup
    {
        fn init(&mut self, _init_data : Box<dyn DataGroupInitParams>) 
        {
            
        }
    }

    fn animation_factory() -> Box<dyn DataGroup>
    {
        return Box::new(AnimationDataGroup{
            clip_name : "Hello world".to_string(),
            duration : 12.4
        });
    }

    register_datagroup_v2!(AnimationDataGroup, animation_factory);

    // -- Second example datagroup

    pub struct MeshDataGroup
    { }

    impl DataGroup for MeshDataGroup
    {
        fn init(&mut self, _init_data : Box<dyn DataGroupInitParams>) 
        {
        }
    }

    fn mesh_factory() -> Box<dyn DataGroup>
    {
        return Box::new(MeshDataGroup{});
    }

    register_datagroup_v2!(MeshDataGroup, mesh_factory);

    #[test]
    fn test_datagroup_registration()
    {
        let global_registry = DataGroupRegistry::get_global_registry();
        let anim_id  = get_id!(AnimationDataGroup);
        let mesh_id  = get_id!(MeshDataGroup);

        let registry = global_registry.lock().unwrap();

        let anim_entry = registry.get_entry_of(anim_id);
        let mesh_entry = registry.get_entry_of(mesh_id);

        assert_eq!(anim_entry.id, anim_id);
        assert_eq!(mesh_entry.id, mesh_id);
    }

    #[test]
    fn test_construction_workflow()
    {
        let registry = DataGroupRegistry::get_global_registry().lock().unwrap();
        let anim_id = get_id!(AnimationDataGroup);
        let anim_datagroup = registry.create(anim_id);
        
        let mesh_id = get_id!(MeshDataGroup);
        let mesh_datagroup = registry.create(mesh_id);

        assert_eq!(mesh_datagroup.get_id(), mesh_id, "Mesh id from object is not the same as mesh id from class");
        assert_eq!(anim_datagroup.get_id(), anim_id, "Anim id from object is not the same as anim id from class");
        assert_ne!(mesh_datagroup.get_id(), anim_datagroup.get_id());
    }

    #[test]
    fn test_init_registry()
    {
        if let Ok(registry) = DataGroupRegistry::get_global_registry().lock().as_mut()
        {
            registry.init();
            for (i, item) in registry.into_iter().enumerate()
            {
                assert_eq!(i as u32, item.id, "Items should be sorted after init so that item accessing is just array indexing");
            }
        }
        else {
            assert!(false, "Could not get lock to global registry because it was poisoned")
        }
    }
}