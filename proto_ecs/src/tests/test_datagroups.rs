use std::any::Any;

use crate::data_group::{DataGroupDesc, DataGroupDyn, DataGroupInitParamsDyn, DataGroupRegistry};
use super::*;

// The following code represents the code that should be generated by our macros 
// To actually implement the datagroup, use this as a guidance.
#[derive(Default)]
struct ExampleHealthDataGroup 
{
    health : u32,
    using_shield : bool
}

struct ExampleHealthDataGroupInitParams
{
    health : u32, 
    using_shield : bool
}

impl DataGroupInitParamsDyn for ExampleHealthDataGroupInitParams
{
    fn as_any(&self) -> &dyn std::any::Any {
        self as &dyn Any
    }
}

impl DataGroupDesc for ExampleHealthDataGroup
{
    fn get_name() -> &'static str
    {
        "ExampleHealthDataGroup"
    }

    fn get_data_group_id() -> u32 {
        42
    }
}

impl DataGroupDyn for ExampleHealthDataGroup 
{
    fn get_name(&self) -> &'static str
    {
        "ExampleHealthDataGroup"
    }

    // TODO Problematic function
    fn dyn_init(&mut self, params: Box<dyn DataGroupInitParamsDyn>) {
        let params = params.as_any();
        let params = params.downcast_ref::<ExampleHealthDataGroupInitParams>();
        let init_params = params.expect("Invalid type of parameter");
        
        // ? How do we init the component here? The init function should be implemented automatically 
        // ? but it's not possible here since all this code should be auto generated by macros
        self.health = init_params.health;
        self.using_shield = init_params.using_shield;
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self as &dyn Any
    }

    fn get_data_group_id(&self) -> u32 {
        42
    }
}

impl data_group::DataGroup for ExampleHealthDataGroup
{
    type InitParams = ExampleHealthDataGroupInitParams;

    fn init(&mut self, params: Self::InitParams) {
        self.health = params.health;
        self.using_shield = params.using_shield;
    }

    fn factory() -> Box<dyn DataGroupDyn> {
        Box::from(Self::default())
    }
}

// Intended api usage should be something like
/*

#[component]
struct MyComponent
{
    ...
}

#[derive(DatagroupInitParamsDyn)]
struct MyInitParams 
{
    ...
}

impl Component for MyComponent
{
    fn init(...)
    {
        ...
    }

    fn factory() -> Box<Dyn DataGroupDyn>
    {
        ...
    }
}

The #[component]  macro invocation should implement datagroup dyn and datagroup desc.
Also register the component in the global component registration system.
*/

// Example macro usage:
mod animation
{
    use crate::data_group;

    #[derive(Default)]
    #[data_group::datagroup]
    pub struct AnimationDataGroup
    { }

    crate::register_datagroup!(AnimationDataGroup);

    impl data_group::DataGroup for AnimationDataGroup
    {
        type InitParams = AnimationInitParams;

        fn init(&mut self, _params: Self::InitParams) {
            // Do something with params
        }

        // TODO It would be cool to have a macro or something to provide an optional default implementation 
        fn factory() -> Box<dyn data_group::DataGroupDyn> {
            Box::from(Self::default())
        }

    }

    #[derive(data_group::DataGroupInitParamsDyn)]
    pub struct AnimationInitParams 
    { }
}
mod mesh
{
    use crate::{data_group, register_datagroup};
    #[derive(Default)]
    #[data_group::datagroup]
    pub struct MeshDataGroup
    { }

    register_datagroup!(MeshDataGroup);

    #[derive(data_group::DataGroupInitParamsDyn)]
    pub struct MeshInitParams
    { }

    impl data_group::DataGroup for MeshDataGroup
    {
        type InitParams = MeshInitParams;
        fn factory() -> Box<dyn data_group::DataGroupDyn> {
            return Box::new(MeshDataGroup::default());
        }

        fn init(&mut self, _params: Self::InitParams) {
            // Do something
        }
    }
}

#[test]
pub fn test_data_group_api()
{
    let anim = animation::AnimationDataGroup{};
    let mesh = mesh::MeshDataGroup{};

    assert_ne!(anim.get_data_group_id(), mesh.get_data_group_id());
    assert_ne!(anim.get_name(), mesh.get_name());
}

#[test]
pub fn test_datagroup_loading()
{   
    // Run with cargo test -- --nocapture to see this output
    let global_registry = DataGroupRegistry::get_global_registry();
    global_registry.lock().and_then(|registry|{

        for item in registry.into_iter()
        {
            println!("My component is: {}", item.name);
        }
        return Ok(());
    }).expect("Should not fail");
}
