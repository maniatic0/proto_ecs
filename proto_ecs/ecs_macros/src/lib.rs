use proc_macro;
use quote::quote;
use std::sync::atomic::{AtomicU32, Ordering};
use syn::{DeriveInput, parse_macro_input, self, parse::Parse};
use crc32fast;

// -- < Datagroups > -----------------------------------
static DATAGROUP_COUNT : AtomicU32 = AtomicU32::new(0);

/// Declare a struct as a datagroup. 
/// 
/// Intended usage: 
/// 
/// #\[datagroup]
/// 
/// struct MyDataGroup
/// { ... }
#[proc_macro_attribute]
pub fn datagroup(attr : proc_macro::TokenStream, item : proc_macro::TokenStream) -> proc_macro::TokenStream
{
    assert!(attr.is_empty());
    
    // We still need the factory fn and init params
    // Parsing name and creating crc
    let item_copy = item.clone();
    let DeriveInput{ident, ..} = syn::parse_macro_input!(item_copy);
    let component_id = DATAGROUP_COUNT.fetch_add(1, Ordering::Relaxed);

    // Extend item with the required trait implementations
    let trait_impls = quote!{

        impl crate::data_group::DataGroupDesc for #ident
        {
            fn get_name() -> &'static str
            {
                std::any::type_name::<#ident>()
            }

            fn get_data_group_id() -> u32
            {
                return #component_id;
            }
        }

        impl crate::data_group::DataGroupDyn for #ident 
        {
            fn get_name(&self) -> &'static str
            {
                std::any::type_name::<#ident>()
            }
            
            fn dyn_init(&mut self, params: Box<dyn crate::data_group::DataGroupInitParamsDyn>) {
                let params = params.as_any();
                // let params = params.downcast_ref::<ExampleHealthDataGroupInitParams>();
                // let init_params = params.expect("Invalid type of parameter");
                // TODO What to do with this function...
                // ? How do we init the component here? The init function should be implemented automatically 
                // ? but it's not possible here since all this code should be auto generated by macros
            }

            fn as_any(&self) -> &dyn std::any::Any {
                self as &dyn std::any::Any
            }

            fn get_data_group_id(&self) -> u32
            {
                <#ident as crate::data_group::DataGroupDesc>::get_data_group_id()  
            }
        }
    };

    let mut item_copy = item.clone();
    item_copy.extend::<proc_macro::TokenStream>(trait_impls.into());

    return item_copy;
}

/// Make this struct usable as InitParams for a datagroup.
/// 
/// #\[derive(InitParams)]
/// 
/// struct MyInitParams
/// { ... }
#[proc_macro_derive(DataGroupInitParamsDyn)]
pub fn derive_datagroup_params(item : proc_macro::TokenStream) -> proc_macro::TokenStream
{
    let DeriveInput { ident, ..} = syn::parse_macro_input!(item);

    return quote!{
        impl crate::data_group::DataGroupInitParamsDyn for #ident
        {
            fn as_any(&self) -> &dyn std::any::Any {
                self as &dyn std::any::Any
            }
        }
    }.into();
}

// -- < Datagroup v2 macros > ----------------------------------------

struct DatagroupInput
{
    datagroup : syn::Ident,
    factory : syn::Ident
}

impl Parse for DatagroupInput
{
    fn parse(input: syn::parse::ParseStream) -> Result<Self, syn::Error> {
        let result = syn::punctuated::Punctuated::<syn::Ident, syn::Token![,]>::parse_terminated(input)?;
        
        if result.len() < 2 
        {
            return Err(syn::Error::new(input.span(), "Expected at the least two identifiers: DataGroup struct and factory function"));
        }

        let datagroup = result[0].clone();
        let factory = result[1].clone();
        
        return Ok(DatagroupInput{datagroup, factory});
    }
}

static DATAGROUP_COUNT2 : AtomicU32 = AtomicU32::new(0);

/// Register a datagroup struct as a new datagroup class in the global registry
#[proc_macro]
pub fn register_datagroup_v2(args : proc_macro::TokenStream) -> proc_macro::TokenStream
{
    let DatagroupInput { datagroup, factory } = parse_macro_input!(args as DatagroupInput);
    let datagroup_str = datagroup.to_string();
    let name_crc = crc32fast::hash(datagroup_str.as_bytes());
    let id = DATAGROUP_COUNT2.fetch_add(1, Ordering::Relaxed);

    let result = quote!{

        // Registration in the global datagroup registry
        const _ : () = {
            #[ctor::ctor]
            fn __register_datagroup__()
            {
                proto_ecs::data_group2::DataGroupRegistry::get_global_registry()
                    .lock()
                    .as_mut()
                    .and_then(
                        |registry|
                        {
                            registry.register(proto_ecs::data_group2::DataGroupRegistryEntry{
                                name: #datagroup_str,
                                name_crc: #name_crc,
                                factory_func: #factory,
                                id: #id
                            });

                            Ok(())
                        }
                    ).expect("Can't access registry due to poisoning");
            }
        };

        // Implement locator trait for registry, 
        // it helps you to find the id for a datagroup using static function calls
        impl proto_ecs::data_group2::DataGroupMetadataLocator<#datagroup> for proto_ecs::data_group2::DataGroupRegistry
        {
            fn get_id() -> proto_ecs::data_group2::DataGroupID
            {
                #id
            }
        }

        // Implement metadata trait for this datagroup. It helps you to 
        // get the id of a datagroup instance, so that you can find its 
        // static data with the global registry
        impl proto_ecs::data_group2::DataGroupMeta for #datagroup
        {
            fn get_id(&self) -> proto_ecs::data_group2::DataGroupID
            {
                #id
            }
        }
    };


    return result.into();
}

#[proc_macro_derive(DataGroupInitParams)]
pub fn derive_datagroup_init_params(item : proc_macro::TokenStream) -> proc_macro::TokenStream
{
    let DeriveInput { ident, ..} = syn::parse_macro_input!(item);

    return quote!{
        impl proto_ecs::data_group2::DataGroupInitParams for #ident
        {
            fn as_any(&self) -> &dyn std::any::Any {
                self as &dyn std::any::Any
            }
        }
    }.into();
}


// -- < Entities > ---------------------------------------------------

static ENTITY_CLASS_COUNT : AtomicU32 = AtomicU32::new(0);

#[proc_macro_attribute]
pub fn entity(attr : proc_macro::TokenStream, item : proc_macro::TokenStream) -> proc_macro::TokenStream
{
    assert!(attr.is_empty());
    let mut item_copy = item.clone();
    let DeriveInput {ident, ..} = parse_macro_input!(item);
    let next_id = ENTITY_CLASS_COUNT.fetch_add(1, Ordering::Relaxed);
    let trait_impls = quote!{
        impl EntityDesc for #ident
        {
            fn get_class_id() -> EntityClassID
            {
                #next_id
            }

            fn get_class_name() -> &'static str
            {
                std::any::type_name::<#ident>()
            }
        }

    };

    item_copy.extend::<proc_macro::TokenStream>(trait_impls.into());
    return  item_copy;
}

// -- < Misc macros > ----------------------------------------

#[proc_macro_derive(CanCast)]
pub fn derive_can_cast(item : proc_macro::TokenStream) -> proc_macro::TokenStream
{
    let DeriveInput { ident, .. } = parse_macro_input!(item);
    
    
    return quote!{
        impl proto_ecs::core::casting::CanCast for #ident
        {
            
            fn as_any(&self) -> &dyn std::any::Any
            {
                self as &dyn std::any::Any
            }
            fn as_any_mut(&mut self) ->&mut dyn std::any::Any
            {
                self as &mut dyn std::any::Any
            }
        
        }
    }.into();
}